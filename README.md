# 🏭 Mini TDD Factory (迷你 AI 軟體工廠)

> **這是個許願池「只要你能把願望講清楚，AI 就能幫你實現。」**

- 這是一個讓 AI 自動幫你寫程式、跑測試的開發工廠，很省力。
- 不管你是什麼程度的開發者 (或 Vibe Coder)，這裡只有一個原則：**「把規格寫好，剩下的交給 AI。」**
- 限制 AI 不准寫壞程式，要修改時，因為它寫成樂高積木，每個小檔案很容易抽換。

---

## 📦 如何使用 (懶人包)

### 方法一：GitHub Template (推薦)

1. 在 GitHub 頁面點擊綠色的 **"Use this template"** 按鈕。
2. 選擇 **"Create a new repository"**。
3. 把你新建立的 Repo Clone 到電腦上。
4. 執行重置腳本：`./reset_project.sh`。

### 方法二：直接下載
如果不使用 GitHub Template：
```bash
git clone https://github.com/richblack/Mini-TDD-Factory.git
cd Mini-TDD-Factory
./reset_project.sh
```

---

## 自動開發及受限的樂高式開發

身為與 AI 合作的開發者，想解決 2 個問題：
- **自動開發**：你希望 AI 幫你寫程式，但它每個動作都問你，變成你陪它開發。
- **樂高式開發**：AI 剛開始寫程式很快，但找錯、修改卻很慢，功能越多越容易出錯。

### 自動開發是什麼？

想像你有一個 **不知疲倦的 AI 實習生**：
1. 你告訴他要做什麼 (寫在需求檔)。
2. 你列出任務清單 (寫在任務檔)。
3. **他會自動幫你寫測試、寫程式、修正錯誤，直到全部完成。**

這就是 **Mini TDD Factory** 的核心精神 —— **TDD (測試驅動開發)** 的自動化。

### 什麼是樂高式開發

為了讓 AI 更好改程式，我們導入了「樂高化」的結構。
如果你選擇用它 (`LEGO_MODE=true`)，AI 會嚴格遵守以下原則，這對 AI 特別友善：

*   **壞了就換**：每個功能都是獨立的小積木。如果一個積木寫爛了，直接刪掉叫 AI 重寫一個，三秒鐘的事。
*   **一檔一事**：每個檔案只做一件事，絕對不超過 100 行。
*   **超級解耦**：A 積木壞了，絕對不會影響到 B 積木。

```text
/
├── contracts/  # 📜 說明書：定義資料長怎樣 (Schema)
├── tests/      # 🧪 測試儀：驗證積木是好的 (Tests)
├── actions/    # 🧱 積木區：核心邏輯，壞了直接丟掉重寫 (Logic)
└── entry/      # 🔌 接頭：API 或是 CLI 指令 (Entry Points)
```

---

## 🛠 開始製作你的第一個功能

### 第一步：安裝環境
確保你有 Python 3，然後安裝必要套件：
```bash
pip install -r requirements.txt
```

### 第二步：檢查設定
打開 `factory_config.md`，確認這兩行是對的：
```markdown
LANGUAGE=python
LEGO_MODE=true
```

### 第三步：許願 (Make a Wish)
你只需要編輯這兩個檔案 (用中文寫)：
1.  **`RFP/requirements.md` (需求書)**：
    寫下你想做什麼。
    > *例：「我要做一個匯率轉換器，輸入台幣顯示美金...」*
2.  **`RFP/tasks.md` (任務單)**：
    把大目標切成小步驟，打勾勾給 AI 看。
    > - [ ] 取得目前匯率
    > - [ ] 實作轉換計算

> 需求規格參考 SDD (Spec Drive Development)，用 Epic, User Story, EARS, Design, Tasks 組成，把需求告訴 AI 要它產生即可，我們不細說。

### 第四步：啟動工廠
在終端機輸入：
```bash
./factory.sh
```
然後你就可以去喝咖啡了。AI 會開始它的 Magic Loop，直到你看見綠燈。

---

## 如果有興趣理解更多

按照前面說明你應該可以開始了，想理解更多，這裏補充背景。

整個的概念是完全配合 AI 開發設計：
- 從前程式最珍貴的是原始碼，因為人類產生程式碼很慢，很昂貴，所以我們儘量不動它，有問題就修修補補。
- 但是 AI 產生程式碼很快，很便宜，所以我們不需要修修補補，壞了就丟掉重寫，反而最重要的是規格。

比喻，假如你是導演
- 從前最珍貴的是膠捲、攝影機、剪輯機、道具，所以我們儘量不動它，有問題就修修補補。
- 但是 AI 時代，規格就是劇本，AI 會自動拍戲，劇本越清楚，製作品質越好，膠捲反而不重要了，哪裡不好重拍就好。

### 自動開發原理：The Ralph Wiggum Loop

這裡採用的核心機制稱為 **The Ralph Wiggum Loop** (致敬 *The Simpsons* 中鍥而不捨的角色 Ralph)：

> **"I'm helping!" - Ralph Wiggum**

這個概念由 Geoffrey Huntley 提出，核心精神是 **「外部驗證驅動 (External Verification Driven)」**。
我們不相信 AI 說的「我做好了」，我們只相信「測試通過」。

工廠啟動後，會進入一個無限迴圈：
1.  **AI 嘗試寫程式**。
2.  **跑測試**：如果有紅燈 (錯誤)，AI 會看到錯誤訊息。
3.  **自動修正**：AI 會根據錯誤，自己修改程式碼，然後**再跑一次**。
4.  **直到綠燈**：直到所有測試都通過，它才會停下來。

這個 Loop 確保了 AI 不會因為「自我感覺良好」而自嗨，它必須通過嚴格的外部檢查才能交卷。

- AI 都有安全機制，凡事要你授權才可執行，以免它亂搞。
- Claude Code 最早允許它自動執行，因為 Claude Code 開發者發現 Ralph Wiggum Loop 太棒了！
- Gemini CLI 也推出 YOLO 模式，類似概念，我們就使用 YOLO 模式，讓 Gemini CLI 也可以自動開發。

### 樂高式開發：解耦重構 (Decoupled Refactoring)

為什麼要用樂高法？因為 **AI 寫程式很快，但維護很爛**。

當專案變大時，AI 往往會改 A 壞 B，這是因為程式碼之間「牽一髮動全身 (Coupling)」。
**樂高式開發 (Lego Methodology)** 的核心就是 **解耦重構**：

*   **AI 開發優勢**：它可以一秒鐘寫出 50 行完美的程式碼。
*   **AI 維護劣勢**：給它 2000 行程式碼，它會頭暈，改錯機率大增。

**策略**：
我們將軟體拆解成無數個極小的 **「原子化」積木**。
*   每個積木 (Action) 都是獨立的、無狀態的、有明確輸入輸出的。
*   **優點**：當一個功能壞掉時，我們**不修它**。我們直接把那個積木拔掉，叫 AI **「重做一個新的」** 塞回去。
*   **結果**：你不需要擔心歷史包袱，永遠保持程式碼跟新的一樣乾淨。

- 這個想法來自於我的個人經驗。
- AI 技高人膽大，會寫出很複雜的程式碼，我有經驗一個檔案裡寫 6000 行程式碼，人類辦不到，到這個長度都不知道誰是誰了。
- 這樣的大程式碼會「你泥中有我，我泥中有你」，結果就是當你要修復一個小功能或是修改時，改好 1 個，壞掉 3 個，要花很多時間再來改。
- 但是沒有不修改的程式碼，想到要改就全身痠痛，樂高式開發，就是把每個功能儘量拆到很小，彼此有明顯界限，抽換一個別的不會壞。

### 把這兩個概念加在一起
- 你只需要搞清楚你要做的是什麼，用 SDD 把細節寫清楚，這些規格都是白話文，不用技術也能懂；
- 剩下的，就交給 AI，它會依照你的驗收標準幫你寫測試規格，然後寫程式、自動測試、自動修正，直到全部通過。
- 擔心自動開發它到底寫了什麼？因為給了規範，它不會亂寫，會寫出品質好而且好維護的程式碼。

---

## 🙏 特別感謝
- **Developer**: Antigravity (Google DeepMind)
- **Model**: Gemini 2.0
- **Concept**: Geoffrey Huntley "Ralph Wiggum Loop" (Verification Driven Development)
